/**
 * This file is part of the "libterminal" project
 *   Copyright (c) 2019-2020 Christian Parpart <christian@parpart.family>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#include <terminal_renderer/CursorRenderer.h>

#include <stdexcept>
#include <vector>

using std::array;
using std::get;
using std::max;
using std::nullopt;
using std::optional;
using std::runtime_error;
using std::string;

using crispy::Size;

namespace terminal::renderer {

CursorRenderer::CursorRenderer(GridMetrics const& _gridMetrics,
                               CursorShape _shape,
                               RGBColor const& _color) :
    gridMetrics_{ _gridMetrics },
    shape_{ _shape },
    color_{ _color },
    columnWidth_{ 1 }
{
}

void CursorRenderer::setRenderTarget(RenderTarget& _renderTarget)
{
    Renderable::setRenderTarget(_renderTarget);
    clearCache();
}

void CursorRenderer::setShape(CursorShape _shape)
{
    if (_shape != shape_)
        shape_ = _shape;
}

void CursorRenderer::clearCache()
{
    textureAtlas_ = std::make_unique<TextureAtlas>(renderTarget().monochromeAtlasAllocator());
}

void CursorRenderer::rebuild()
{
    clearCache();

    auto const width = gridMetrics_.cellSize.width * columnWidth_;
    auto const baseline = gridMetrics_.baseline;
    auto constexpr LineThickness = 1u;

    { // {{{ CursorShape::Block
        auto const height = gridMetrics_.cellSize.height;
        auto image = atlas::Buffer(width * height, 0xFFu);

        textureAtlas_->insert(
            CursorShape::Block,
            Size{width, height},
            Size{width, height},
            move(image)
        );
    } // }}}
    { // {{{ CursorShape::Underscore
        auto const thickness = max(LineThickness * baseline / 3, 1u);
        auto const height = baseline;
        auto const base_y = height > thickness ? (height - thickness) / 2 : 0;
        auto image = atlas::Buffer(width * height, 0);

        for (int y = 1; y <= thickness; ++y)
            for (int x = 0; x < width; ++x)
                image[(base_y + y) * width + x] = 0xFF;

        textureAtlas_->insert(
            CursorShape::Underscore,
            Size{width, height},
            Size{width, height},
            move(image)
        );
    } // }}}
    { // {{{ CursorShape::Bar
        auto const thickness = max(LineThickness * baseline / 3, 1u);
        auto const height = gridMetrics_.cellSize.height;
        //auto const base_y = max((height - thickness) / 2, 0);
        auto image = atlas::Buffer(width * height, 0);

        for (int x = 0; x < thickness; ++x)
            for (int y = 0; y < height; ++y)
                image[y * width + x] = 0xFF;

        textureAtlas_->insert(
            CursorShape::Bar,
            Size{width, height},
            Size{width, height},
            move(image)
        );
    } // }}}
    { // {{{ CursorShape::Rectangle
        auto const height = gridMetrics_.cellSize.height;
        auto image = atlas::Buffer(width * height, 0xFFu);
        auto const thickness = max(width / 12, 1u);

        auto const innerWidth = width - 2 * thickness;
        auto const innerHeight = height - 2 * thickness;

        for (int y = thickness; y <= innerHeight; ++y)
            for (int x = thickness; x <= innerWidth; ++x)
                image[y * width + x] = 0;

        textureAtlas_->insert(
            CursorShape::Rectangle,
            Size{width, height},
            Size{width, height},
            move(image)
        );
    } // }}}
}

optional<CursorRenderer::DataRef> CursorRenderer::getDataRef(CursorShape _shape)
{
    if (optional<DataRef> const dataRef = textureAtlas_->get(_shape); dataRef.has_value())
        return dataRef;

    if (textureAtlas_->empty())
        rebuild();

    if (optional<DataRef> const dataRef = textureAtlas_->get(_shape); dataRef.has_value())
        return dataRef;

    return nullopt;
}

void CursorRenderer::render(crispy::Point _pos, int _columnWidth)
{
    if (columnWidth_ != _columnWidth) // TODO we should optimize here by keying for (shape, columnWidth).
    {
        columnWidth_ = _columnWidth;
        rebuild();
    }

    if (optional<DataRef> const dataRef = getDataRef(shape_); dataRef.has_value())
    {
        auto const& textureInfo = get<0>(dataRef.value()).get();
        auto const x = static_cast<unsigned>(_pos.x);
        auto const y = static_cast<unsigned>(_pos.y);
        auto constexpr z = 0;
        textureScheduler().renderTexture({textureInfo, x, y, z, color()});
    }
}

std::array<float, 4> CursorRenderer::color() const noexcept
{
    return {
        float(color_.red) / 255.0f,
        float(color_.green) / 255.0f,
        float(color_.blue) / 255.0f,
        1.0f
    };
}

} // namespace terminal::view
